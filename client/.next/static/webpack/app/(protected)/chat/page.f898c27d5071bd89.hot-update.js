"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(protected)/chat/page",{

/***/ "(app-pages-browser)/./hooks/useChat.ts":
/*!**************************!*\
  !*** ./hooks/useChat.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChat: function() { return /* binding */ useChat; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_uiCopy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/uiCopy */ \"(app-pages-browser)/./lib/uiCopy.ts\");\n/* __next_internal_client_entry_do_not_use__ useChat auto */ \n\n// Helper pour gérer les erreurs de l'API\nasync function getApiErrorMessage(error) {\n    if (error.response) {\n        try {\n            var _data_error;\n            const data = await error.response.json();\n            const errorCode = (_data_error = data.error) === null || _data_error === void 0 ? void 0 : _data_error.code;\n            if (errorCode && _lib_uiCopy__WEBPACK_IMPORTED_MODULE_1__.uiCopy.errors[errorCode]) {\n                return _lib_uiCopy__WEBPACK_IMPORTED_MODULE_1__.uiCopy.errors[errorCode];\n            }\n        } catch (e) {\n            // Le corps de la réponse n'est pas un JSON valide\n            return _lib_uiCopy__WEBPACK_IMPORTED_MODULE_1__.uiCopy.errors.UNKNOWN_ERROR;\n        }\n    }\n    if (error.message.includes(\"Failed to fetch\")) {\n        return _lib_uiCopy__WEBPACK_IMPORTED_MODULE_1__.uiCopy.errors.network;\n    }\n    return _lib_uiCopy__WEBPACK_IMPORTED_MODULE_1__.uiCopy.errors.UNKNOWN_ERROR;\n}\nfunction useChat() {\n    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const { userId, autoLoadHistory = true, userContext } = options;\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        messages: [],\n        isLoading: false,\n        error: null,\n        connectionStatus: \"disconnected\"\n    });\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // 📜 Charger l'historique au montage\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (autoLoadHistory && userId) {\n            loadChatHistory();\n        }\n    }, [\n        userId,\n        autoLoadHistory\n    ]);\n    // 📜 Charger historique conversation\n    const loadChatHistory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!userId) {\n            setState((prev)=>({\n                    ...prev,\n                    isLoading: false,\n                    connectionStatus: \"disconnected\"\n                }));\n            return;\n        }\n        try {\n            setState((prev)=>({\n                    ...prev,\n                    isLoading: true,\n                    connectionStatus: \"connecting\"\n                }));\n            const response = await fetch(\"/api/chat/history?userId=\".concat(userId));\n            if (!response.ok) {\n                throw {\n                    response\n                }; // Lancer l'objet réponse pour analyse\n            }\n            const data = await response.json();\n            setState((prev)=>({\n                    ...prev,\n                    messages: data.messages || [],\n                    isLoading: false,\n                    connectionStatus: \"connected\",\n                    error: null\n                }));\n        } catch (error) {\n            console.error(\"Erreur chargement historique:\", error);\n            const errorMessage = await getApiErrorMessage(error);\n            setState((prev)=>({\n                    ...prev,\n                    isLoading: false,\n                    connectionStatus: \"disconnected\",\n                    error: errorMessage\n                }));\n        }\n    }, [\n        userId\n    ]);\n    // 💬 Envoyer un message\n    const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (content)=>{\n        if (!content.trim() || state.isLoading || !userId) {\n            return;\n        }\n        // Annuler requête précédente si elle existe\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n        }\n        abortControllerRef.current = new AbortController();\n        // Message utilisateur immédiat\n        const userMessage = {\n            id: \"user-\".concat(Date.now()),\n            role: \"user\",\n            content: content.trim(),\n            timestamp: new Date().toISOString()\n        };\n        setState((prev)=>({\n                ...prev,\n                messages: [\n                    ...prev.messages,\n                    userMessage\n                ],\n                isLoading: true,\n                error: null\n            }));\n        try {\n            // 🔐 Récupérer le token Supabase depuis les cookies\n            const { supabase } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\"));\n            const { data: { session } } = await supabase.auth.getSession();\n            const token = session === null || session === void 0 ? void 0 : session.access_token;\n            if (!token) {\n                throw new Error(\"Session expir\\xe9e\");\n            }\n            const response = await fetch(\"/api/chat/message\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Authorization\": \"Bearer \".concat(token) // 🔐 Ajouter le token\n                },\n                body: JSON.stringify({\n                    message: content.trim(),\n                    userId,\n                    context: userContext // Envoyer le contexte utilisateur\n                }),\n                signal: abortControllerRef.current.signal\n            });\n            if (!response.ok) {\n                throw {\n                    response\n                }; // Lancer l'objet réponse pour analyse\n            }\n            const data = await response.json();\n            // Message assistant avec données RAG\n            const assistantMessage = {\n                id: \"assistant-\".concat(Date.now()),\n                role: \"assistant\",\n                content: data.response || data.answer,\n                timestamp: data.timestamp,\n                sources: data.sources || [],\n                processing_time: data.processing_time || 0,\n                suggestions: data.suggestions || []\n            };\n            setState((prev)=>({\n                    ...prev,\n                    messages: [\n                        ...prev.messages,\n                        assistantMessage\n                    ],\n                    isLoading: false,\n                    connectionStatus: \"connected\"\n                }));\n        } catch (error) {\n            if (error.name === \"AbortError\") {\n                return; // Requête annulée volontairement\n            }\n            console.error(\"Erreur envoi message:\", error);\n            const errorMessage = await getApiErrorMessage(error);\n            setState((prev)=>({\n                    ...prev,\n                    isLoading: false,\n                    connectionStatus: \"disconnected\",\n                    error: errorMessage\n                }));\n        }\n    }, [\n        userId,\n        state.isLoading\n    ]);\n    // 🔄 Reset conversation\n    const resetConversation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!userId) {\n            return;\n        }\n        try {\n            setState((prev)=>({\n                    ...prev,\n                    isLoading: true\n                }));\n            const response = await fetch(\"/api/chat/reset\", {\n                method: \"DELETE\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    userId\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Erreur lors de la r\\xe9initialisation\");\n            }\n            setState((prev)=>({\n                    ...prev,\n                    messages: [],\n                    isLoading: false,\n                    error: null\n                }));\n        } catch (error) {\n            console.error(\"Erreur reset:\", error);\n            setState((prev)=>({\n                    ...prev,\n                    isLoading: false,\n                    error: error.message\n                }));\n        }\n    }, [\n        userId\n    ]);\n    // 🧠 Sauvegarder un souvenir important\n    const saveMemory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async function(memory) {\n        let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"important\";\n        if (!userId) {\n            return false;\n        }\n        try {\n            const response = await fetch(\"/api/chat/memory\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    userId,\n                    memory,\n                    type\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Erreur sauvegarde m\\xe9moire\");\n            }\n            return true;\n        } catch (error) {\n            console.error(\"Erreur sauvegarde m\\xe9moire:\", error);\n            return false;\n        }\n    }, [\n        userId\n    ]);\n    // 📄 Analyser un document\n    const analyzeDocument = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (document, documentType)=>{\n        if (!userId) {\n            return null;\n        }\n        try {\n            setState((prev)=>({\n                    ...prev,\n                    isLoading: true\n                }));\n            const response = await fetch(\"/api/chat/analyze-document\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    document,\n                    userId,\n                    documentType\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Erreur analyse document\");\n            }\n            const data = await response.json();\n            // Ajouter résultat d'analyse comme message\n            const analysisMessage = {\n                id: \"analysis-\".concat(Date.now()),\n                role: \"assistant\",\n                content: \"\\uD83D\\uDCC4 **Analyse de votre document :**\\n\\n\".concat(data.analysis, \"\\n\\n**Suggestions :**\\n\").concat(data.suggestions.map((s)=>\"• \".concat(s)).join(\"\\n\")),\n                timestamp: new Date().toISOString()\n            };\n            setState((prev)=>({\n                    ...prev,\n                    messages: [\n                        ...prev.messages,\n                        analysisMessage\n                    ],\n                    isLoading: false\n                }));\n            return data;\n        } catch (error) {\n            console.error(\"Erreur analyse document:\", error);\n            setState((prev)=>({\n                    ...prev,\n                    isLoading: false,\n                    error: error.message\n                }));\n            return null;\n        }\n    }, [\n        userId\n    ]);\n    // 🔄 Retry dernière action en cas d'erreur\n    const retry = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (state.messages.length > 0) {\n            const lastUserMessage = [\n                ...state.messages\n            ].reverse().find((m)=>m.role === \"user\");\n            if (lastUserMessage) {\n                // Supprimer les messages d'erreur et relancer\n                setState((prev)=>({\n                        ...prev,\n                        messages: prev.messages.filter((m)=>!m.id.startsWith(\"error-\")),\n                        error: null\n                    }));\n                sendMessage(lastUserMessage.content);\n            }\n        }\n    }, [\n        state.messages,\n        sendMessage\n    ]);\n    return {\n        // State\n        messages: state.messages,\n        isLoading: state.isLoading,\n        error: state.error,\n        connectionStatus: state.connectionStatus,\n        // Actions\n        sendMessage,\n        resetConversation,\n        saveMemory,\n        analyzeDocument,\n        loadChatHistory,\n        retry,\n        // Utils\n        isEmpty: state.messages.length === 0,\n        lastMessage: state.messages[state.messages.length - 1] || null\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFFWCwyQ0FBMkM7SUFDM0MsTUFBTTRELFFBQVEvRSxrREFBV0EsQ0FBQztRQUN4QixJQUFJc0IsTUFBTUUsUUFBUSxDQUFDd0QsTUFBTSxHQUFHLEdBQUc7WUFDN0IsTUFBTUMsa0JBQWtCO21CQUFJM0QsTUFBTUUsUUFBUTthQUFDLENBQUMwRCxPQUFPLEdBQUdDLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRXhDLElBQUksS0FBSztZQUMzRSxJQUFJcUMsaUJBQWlCO2dCQUNuQiw4Q0FBOEM7Z0JBQzlDMUQsU0FBU00sQ0FBQUEsT0FBUzt3QkFDaEIsR0FBR0EsSUFBSTt3QkFDUEwsVUFBVUssS0FBS0wsUUFBUSxDQUFDNkQsTUFBTSxDQUFDRCxDQUFBQSxJQUFLLENBQUNBLEVBQUUzQyxFQUFFLENBQUM2QyxVQUFVLENBQUM7d0JBQ3JEakYsT0FBTztvQkFDVDtnQkFDQTZCLFlBQVkrQyxnQkFBZ0I5QyxPQUFPO1lBQ3JDO1FBQ0Y7SUFDRixHQUFHO1FBQUNiLE1BQU1FLFFBQVE7UUFBRVU7S0FBWTtJQUVoQyxPQUFPO1FBQ0wsUUFBUTtRQUNSVixVQUFVRixNQUFNRSxRQUFRO1FBQ3hCQyxXQUFXSCxNQUFNRyxTQUFTO1FBQzFCcEIsT0FBT2lCLE1BQU1qQixLQUFLO1FBQ2xCcUIsa0JBQWtCSixNQUFNSSxnQkFBZ0I7UUFFeEMsVUFBVTtRQUNWUTtRQUNBaUM7UUFDQUM7UUFDQUc7UUFDQTNDO1FBQ0FtRDtRQUVBLFFBQVE7UUFDUlEsU0FBU2pFLE1BQU1FLFFBQVEsQ0FBQ3dELE1BQU0sS0FBSztRQUNuQ1EsYUFBYWxFLE1BQU1FLFFBQVEsQ0FBQ0YsTUFBTUUsUUFBUSxDQUFDd0QsTUFBTSxHQUFHLEVBQUUsSUFBSTtJQUM1RDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZUNoYXQudHM/YzJkYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IHVpQ29weSB9IGZyb20gJ0AvbGliL3VpQ29weSc7XG5cbmludGVyZmFjZSBNZXNzYWdlIHtcbiAgaWQ6IHN0cmluZztcbiAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7XG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgdGltZXN0YW1wOiBzdHJpbmc7XG4gIHNvdXJjZXM/OiBzdHJpbmdbXTtcbiAgcHJvY2Vzc2luZ190aW1lPzogbnVtYmVyO1xuICBzdWdnZXN0aW9ucz86IHN0cmluZ1tdO1xufVxuXG5pbnRlcmZhY2UgQ2hhdFN0YXRlIHtcbiAgbWVzc2FnZXM6IE1lc3NhZ2VbXTtcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICBlcnJvcjogc3RyaW5nIHwgbnVsbDtcbiAgY29ubmVjdGlvblN0YXR1czogJ2Nvbm5lY3RlZCcgfCAnZGlzY29ubmVjdGVkJyB8ICdjb25uZWN0aW5nJztcbn1cblxuaW50ZXJmYWNlIFVzZUNoYXRPcHRpb25zIHtcbiAgdXNlcklkPzogc3RyaW5nO1xuICBhdXRvTG9hZEhpc3Rvcnk/OiBib29sZWFuO1xuICB1c2VyQ29udGV4dD86IGFueTtcbn1cblxuLy8gSGVscGVyIHBvdXIgZ8OpcmVyIGxlcyBlcnJldXJzIGRlIGwnQVBJXG5hc3luYyBmdW5jdGlvbiBnZXRBcGlFcnJvck1lc3NhZ2UoZXJyb3I6IGFueSk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGlmIChlcnJvci5yZXNwb25zZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZXJyb3IucmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc3QgZXJyb3JDb2RlID0gZGF0YS5lcnJvcj8uY29kZSBhcyBrZXlvZiB0eXBlb2YgdWlDb3B5LmVycm9ycztcbiAgICAgIGlmIChlcnJvckNvZGUgJiYgdWlDb3B5LmVycm9yc1tlcnJvckNvZGVdKSB7XG4gICAgICAgIHJldHVybiB1aUNvcHkuZXJyb3JzW2Vycm9yQ29kZV07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gTGUgY29ycHMgZGUgbGEgcsOpcG9uc2Ugbidlc3QgcGFzIHVuIEpTT04gdmFsaWRlXG4gICAgICByZXR1cm4gdWlDb3B5LmVycm9ycy5VTktOT1dOX0VSUk9SO1xuICAgIH1cbiAgfVxuICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnRmFpbGVkIHRvIGZldGNoJykpIHtcbiAgICByZXR1cm4gdWlDb3B5LmVycm9ycy5uZXR3b3JrO1xuICB9XG4gIHJldHVybiB1aUNvcHkuZXJyb3JzLlVOS05PV05fRVJST1I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGF0KG9wdGlvbnM6IFVzZUNoYXRPcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB1c2VySWQsIGF1dG9Mb2FkSGlzdG9yeSA9IHRydWUsIHVzZXJDb250ZXh0IH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8Q2hhdFN0YXRlPih7XG4gICAgbWVzc2FnZXM6IFtdLFxuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgY29ubmVjdGlvblN0YXR1czogJ2Rpc2Nvbm5lY3RlZCdcbiAgfSk7XG5cbiAgY29uc3QgYWJvcnRDb250cm9sbGVyUmVmID0gdXNlUmVmPEFib3J0Q29udHJvbGxlciB8IG51bGw+KG51bGwpO1xuXG4gIC8vIPCfk5wgQ2hhcmdlciBsJ2hpc3RvcmlxdWUgYXUgbW9udGFnZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChhdXRvTG9hZEhpc3RvcnkgJiYgdXNlcklkKSB7XG4gICAgICBsb2FkQ2hhdEhpc3RvcnkoKTtcbiAgICB9XG4gIH0sIFt1c2VySWQsIGF1dG9Mb2FkSGlzdG9yeV0pO1xuXG4gIC8vIPCfk5wgQ2hhcmdlciBoaXN0b3JpcXVlIGNvbnZlcnNhdGlvblxuICBjb25zdCBsb2FkQ2hhdEhpc3RvcnkgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCF1c2VySWQpIHtcbiAgICAgIHNldFN0YXRlKChwcmV2KSA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiAnZGlzY29ubmVjdGVkJyxcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2V0U3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBpc0xvYWRpbmc6IHRydWUsIGNvbm5lY3Rpb25TdGF0dXM6ICdjb25uZWN0aW5nJyB9KSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvY2hhdC9oaXN0b3J5P3VzZXJJZD0ke3VzZXJJZH1gKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyB7IHJlc3BvbnNlIH07IC8vIExhbmNlciBsJ29iamV0IHLDqXBvbnNlIHBvdXIgYW5hbHlzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIG1lc3NhZ2VzOiBkYXRhLm1lc3NhZ2VzIHx8IFtdLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiAnY29ubmVjdGVkJyxcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH0pKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJldXIgY2hhcmdlbWVudCBoaXN0b3JpcXVlOicsIGVycm9yKTtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGF3YWl0IGdldEFwaUVycm9yTWVzc2FnZShlcnJvcik7XG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6ICdkaXNjb25uZWN0ZWQnLFxuICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCBbdXNlcklkXSk7XG5cbiAgLy8g8J+SrCBFbnZveWVyIHVuIG1lc3NhZ2VcbiAgY29uc3Qgc2VuZE1lc3NhZ2UgPSB1c2VDYWxsYmFjayhhc3luYyAoY29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFjb250ZW50LnRyaW0oKSB8fCBzdGF0ZS5pc0xvYWRpbmcgfHwgIXVzZXJJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEFubnVsZXIgcmVxdcOqdGUgcHLDqWPDqWRlbnRlIHNpIGVsbGUgZXhpc3RlXG4gICAgaWYgKGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50KSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudC5hYm9ydCgpO1xuICAgIH1cblxuICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXG4gICAgLy8gTWVzc2FnZSB1dGlsaXNhdGV1ciBpbW3DqWRpYXRcbiAgICBjb25zdCB1c2VyTWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgIGlkOiBgdXNlci0ke0RhdGUubm93KCl9YCxcbiAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnQudHJpbSgpLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9O1xuXG4gICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIG1lc3NhZ2VzOiBbLi4ucHJldi5tZXNzYWdlcywgdXNlck1lc3NhZ2VdLFxuICAgICAgaXNMb2FkaW5nOiB0cnVlLFxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9KSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8g8J+UkCBSw6ljdXDDqXJlciBsZSB0b2tlbiBTdXBhYmFzZSBkZXB1aXMgbGVzIGNvb2tpZXNcbiAgICAgIGNvbnN0IHsgc3VwYWJhc2UgfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvc3VwYWJhc2UnKTtcbiAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpO1xuICAgICAgY29uc3QgdG9rZW4gPSBzZXNzaW9uPy5hY2Nlc3NfdG9rZW47XG5cbiAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXNzaW9uIGV4cGlyw6llJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvY2hhdC9tZXNzYWdlJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YCAvLyDwn5SQIEFqb3V0ZXIgbGUgdG9rZW5cbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIG1lc3NhZ2U6IGNvbnRlbnQudHJpbSgpLFxuICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICBjb250ZXh0OiB1c2VyQ29udGV4dCAvLyBFbnZveWVyIGxlIGNvbnRleHRlIHV0aWxpc2F0ZXVyXG4gICAgICAgIH0pLFxuICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LnNpZ25hbCxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IHsgcmVzcG9uc2UgfTsgLy8gTGFuY2VyIGwnb2JqZXQgcsOpcG9uc2UgcG91ciBhbmFseXNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIE1lc3NhZ2UgYXNzaXN0YW50IGF2ZWMgZG9ubsOpZXMgUkFHXG4gICAgICBjb25zdCBhc3Npc3RhbnRNZXNzYWdlOiBNZXNzYWdlID0ge1xuICAgICAgICBpZDogYGFzc2lzdGFudC0ke0RhdGUubm93KCl9YCxcbiAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgIGNvbnRlbnQ6IGRhdGEucmVzcG9uc2UgfHwgZGF0YS5hbnN3ZXIsXG4gICAgICAgIHRpbWVzdGFtcDogZGF0YS50aW1lc3RhbXAsXG4gICAgICAgIHNvdXJjZXM6IGRhdGEuc291cmNlcyB8fCBbXSxcbiAgICAgICAgcHJvY2Vzc2luZ190aW1lOiBkYXRhLnByb2Nlc3NpbmdfdGltZSB8fCAwLFxuICAgICAgICBzdWdnZXN0aW9uczogZGF0YS5zdWdnZXN0aW9ucyB8fCBbXVxuICAgICAgfTtcblxuICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBtZXNzYWdlczogWy4uLnByZXYubWVzc2FnZXMsIGFzc2lzdGFudE1lc3NhZ2VdLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiAnY29ubmVjdGVkJ1xuICAgICAgfSkpO1xuXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICByZXR1cm47IC8vIFJlcXXDqnRlIGFubnVsw6llIHZvbG9udGFpcmVtZW50XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0VycmV1ciBlbnZvaSBtZXNzYWdlOicsIGVycm9yKTtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGF3YWl0IGdldEFwaUVycm9yTWVzc2FnZShlcnJvcik7XG5cbiAgICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgY29ubmVjdGlvblN0YXR1czogJ2Rpc2Nvbm5lY3RlZCcsXG4gICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIFt1c2VySWQsIHN0YXRlLmlzTG9hZGluZ10pO1xuXG4gIC8vIPCflIQgUmVzZXQgY29udmVyc2F0aW9uXG4gIGNvbnN0IHJlc2V0Q29udmVyc2F0aW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdXNlcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7IC4uLnByZXYsIGlzTG9hZGluZzogdHJ1ZSB9KSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvY2hhdC9yZXNldCcsIHtcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICB1c2VySWRcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VycmV1ciBsb3JzIGRlIGxhIHLDqWluaXRpYWxpc2F0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfSkpO1xuXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyZXVyIHJlc2V0OicsIGVycm9yKTtcbiAgICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIFt1c2VySWRdKTtcblxuICAvLyDwn6egIFNhdXZlZ2FyZGVyIHVuIHNvdXZlbmlyIGltcG9ydGFudFxuICBjb25zdCBzYXZlTWVtb3J5ID0gdXNlQ2FsbGJhY2soYXN5bmMgKG1lbW9yeTogc3RyaW5nLCB0eXBlOiBzdHJpbmcgPSAnaW1wb3J0YW50JykgPT4ge1xuICAgIGlmICghdXNlcklkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2NoYXQvbWVtb3J5Jywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgbWVtb3J5LFxuICAgICAgICAgIHR5cGVcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VycmV1ciBzYXV2ZWdhcmRlIG3DqW1vaXJlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJldXIgc2F1dmVnYXJkZSBtw6ltb2lyZTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCBbdXNlcklkXSk7XG5cbiAgLy8g8J+ThCBBbmFseXNlciB1biBkb2N1bWVudFxuICBjb25zdCBhbmFseXplRG9jdW1lbnQgPSB1c2VDYWxsYmFjayhhc3luYyAoZG9jdW1lbnQ6IHN0cmluZywgZG9jdW1lbnRUeXBlOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7IC4uLnByZXYsIGlzTG9hZGluZzogdHJ1ZSB9KSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvY2hhdC9hbmFseXplLWRvY3VtZW50Jywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgZG9jdW1lbnRUeXBlXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJldXIgYW5hbHlzZSBkb2N1bWVudCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBBam91dGVyIHLDqXN1bHRhdCBkJ2FuYWx5c2UgY29tbWUgbWVzc2FnZVxuICAgICAgY29uc3QgYW5hbHlzaXNNZXNzYWdlOiBNZXNzYWdlID0ge1xuICAgICAgICBpZDogYGFuYWx5c2lzLSR7RGF0ZS5ub3coKX1gLFxuICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgY29udGVudDogYPCfk4QgKipBbmFseXNlIGRlIHZvdHJlIGRvY3VtZW50IDoqKlxcblxcbiR7ZGF0YS5hbmFseXNpc31cXG5cXG4qKlN1Z2dlc3Rpb25zIDoqKlxcbiR7ZGF0YS5zdWdnZXN0aW9ucy5tYXAoKHM6IHN0cmluZykgPT4gYOKAoiAke3N9YCkuam9pbignXFxuJyl9YCxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH07XG5cbiAgICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgbWVzc2FnZXM6IFsuLi5wcmV2Lm1lc3NhZ2VzLCBhbmFseXNpc01lc3NhZ2VdLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyZXVyIGFuYWx5c2UgZG9jdW1lbnQ6JywgZXJyb3IpO1xuICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCBbdXNlcklkXSk7XG5cbiAgLy8g8J+UhCBSZXRyeSBkZXJuacOocmUgYWN0aW9uIGVuIGNhcyBkJ2VycmV1clxuICBjb25zdCByZXRyeSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoc3RhdGUubWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbGFzdFVzZXJNZXNzYWdlID0gWy4uLnN0YXRlLm1lc3NhZ2VzXS5yZXZlcnNlKCkuZmluZChtID0+IG0ucm9sZSA9PT0gJ3VzZXInKTtcbiAgICAgIGlmIChsYXN0VXNlck1lc3NhZ2UpIHtcbiAgICAgICAgLy8gU3VwcHJpbWVyIGxlcyBtZXNzYWdlcyBkJ2VycmV1ciBldCByZWxhbmNlclxuICAgICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICBtZXNzYWdlczogcHJldi5tZXNzYWdlcy5maWx0ZXIobSA9PiAhbS5pZC5zdGFydHNXaXRoKCdlcnJvci0nKSksXG4gICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgfSkpO1xuICAgICAgICBzZW5kTWVzc2FnZShsYXN0VXNlck1lc3NhZ2UuY29udGVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbc3RhdGUubWVzc2FnZXMsIHNlbmRNZXNzYWdlXSk7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBTdGF0ZVxuICAgIG1lc3NhZ2VzOiBzdGF0ZS5tZXNzYWdlcyxcbiAgICBpc0xvYWRpbmc6IHN0YXRlLmlzTG9hZGluZyxcbiAgICBlcnJvcjogc3RhdGUuZXJyb3IsXG4gICAgY29ubmVjdGlvblN0YXR1czogc3RhdGUuY29ubmVjdGlvblN0YXR1cyxcblxuICAgIC8vIEFjdGlvbnNcbiAgICBzZW5kTWVzc2FnZSxcbiAgICByZXNldENvbnZlcnNhdGlvbixcbiAgICBzYXZlTWVtb3J5LFxuICAgIGFuYWx5emVEb2N1bWVudCxcbiAgICBsb2FkQ2hhdEhpc3RvcnksXG4gICAgcmV0cnksXG5cbiAgICAvLyBVdGlsc1xuICAgIGlzRW1wdHk6IHN0YXRlLm1lc3NhZ2VzLmxlbmd0aCA9PT0gMCxcbiAgICBsYXN0TWVzc2FnZTogc3RhdGUubWVzc2FnZXNbc3RhdGUubWVzc2FnZXMubGVuZ3RoIC0gMV0gfHwgbnVsbFxuICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJ1aUNvcHkiLCJnZXRBcGlFcnJvck1lc3NhZ2UiLCJlcnJvciIsInJlc3BvbnNlIiwiZGF0YSIsImpzb24iLCJlcnJvckNvZGUiLCJjb2RlIiwiZXJyb3JzIiwiZSIsIlVOS05PV05fRVJST1IiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJuZXR3b3JrIiwidXNlQ2hhdCIsIm9wdGlvbnMiLCJ1c2VySWQiLCJhdXRvTG9hZEhpc3RvcnkiLCJ1c2VyQ29udGV4dCIsInN0YXRlIiwic2V0U3RhdGUiLCJtZXNzYWdlcyIsImlzTG9hZGluZyIsImNvbm5lY3Rpb25TdGF0dXMiLCJhYm9ydENvbnRyb2xsZXJSZWYiLCJsb2FkQ2hhdEhpc3RvcnkiLCJwcmV2IiwiZmV0Y2giLCJvayIsImNvbnNvbGUiLCJlcnJvck1lc3NhZ2UiLCJzZW5kTWVzc2FnZSIsImNvbnRlbnQiLCJ0cmltIiwiY3VycmVudCIsImFib3J0IiwiQWJvcnRDb250cm9sbGVyIiwidXNlck1lc3NhZ2UiLCJpZCIsIkRhdGUiLCJub3ciLCJyb2xlIiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJzdXBhYmFzZSIsInNlc3Npb24iLCJhdXRoIiwiZ2V0U2Vzc2lvbiIsInRva2VuIiwiYWNjZXNzX3Rva2VuIiwiRXJyb3IiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb250ZXh0Iiwic2lnbmFsIiwiYXNzaXN0YW50TWVzc2FnZSIsImFuc3dlciIsInNvdXJjZXMiLCJwcm9jZXNzaW5nX3RpbWUiLCJzdWdnZXN0aW9ucyIsIm5hbWUiLCJyZXNldENvbnZlcnNhdGlvbiIsInNhdmVNZW1vcnkiLCJtZW1vcnkiLCJ0eXBlIiwiYW5hbHl6ZURvY3VtZW50IiwiZG9jdW1lbnQiLCJkb2N1bWVudFR5cGUiLCJhbmFseXNpc01lc3NhZ2UiLCJhbmFseXNpcyIsIm1hcCIsInMiLCJqb2luIiwicmV0cnkiLCJsZW5ndGgiLCJsYXN0VXNlck1lc3NhZ2UiLCJyZXZlcnNlIiwiZmluZCIsIm0iLCJmaWx0ZXIiLCJzdGFydHNXaXRoIiwiaXNFbXB0eSIsImxhc3RNZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useChat.ts\n"));

/***/ })

});