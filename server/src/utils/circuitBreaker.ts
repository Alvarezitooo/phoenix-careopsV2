/**
 * üîå Circuit Breaker Pattern
 *
 * Prot√®ge le syst√®me contre les d√©faillances en cascade.
 * √âtats : CLOSED (normal) ‚Üí OPEN (fail) ‚Üí HALF_OPEN (test recovery)
 */

export enum CircuitState {
  CLOSED = 'CLOSED',      // Tout va bien, requ√™tes passent
  OPEN = 'OPEN',          // Service down, requ√™tes bloqu√©es
  HALF_OPEN = 'HALF_OPEN' // Test de r√©cup√©ration
}

export interface CircuitBreakerOptions {
  failureThreshold: number;    // Nombre d'√©checs avant ouverture (d√©faut: 5)
  successThreshold: number;    // Nombre de succ√®s pour fermer (d√©faut: 2)
  timeout: number;             // Dur√©e en OPEN avant HALF_OPEN (ms, d√©faut: 60000)
  name?: string;               // Nom du circuit (pour logs)
}

export interface CircuitBreakerStats {
  state: CircuitState;
  failures: number;
  successes: number;
  lastFailureTime?: number;
  totalCalls: number;
  totalFailures: number;
}

export class CircuitBreaker {
  private state: CircuitState = CircuitState.CLOSED;
  private failureCount: number = 0;
  private successCount: number = 0;
  private lastFailureTime?: number;
  private nextAttemptTime?: number;

  // Stats
  private totalCalls: number = 0;
  private totalFailures: number = 0;

  private readonly failureThreshold: number;
  private readonly successThreshold: number;
  private readonly timeout: number;
  private readonly name: string;

  constructor(options: Partial<CircuitBreakerOptions> = {}) {
    this.failureThreshold = options.failureThreshold ?? 5;
    this.successThreshold = options.successThreshold ?? 2;
    this.timeout = options.timeout ?? 60000; // 1 minute
    this.name = options.name ?? 'default';
  }

  /**
   * Ex√©cute une fonction prot√©g√©e par le circuit breaker
   */
  async execute<T>(
    fn: () => Promise<T>,
    fallback?: () => Promise<T>
  ): Promise<T> {
    this.totalCalls++;

    // Si circuit OPEN, v√©rifier si on peut tester la r√©cup√©ration
    if (this.state === CircuitState.OPEN) {
      if (this.nextAttemptTime && Date.now() < this.nextAttemptTime) {
        console.warn(
          `[CircuitBreaker:${this.name}] Circuit OPEN - Fallback activ√©`
        );

        if (fallback) {
          return fallback();
        }

        throw new Error(
          `Circuit breaker is OPEN for ${this.name}. Service temporarily unavailable.`
        );
      }

      // Passer en HALF_OPEN pour tester
      this.state = CircuitState.HALF_OPEN;
      this.successCount = 0;
      console.log(`[CircuitBreaker:${this.name}] Transition: OPEN ‚Üí HALF_OPEN`);
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();

      // Si fallback disponible, l'utiliser
      if (fallback) {
        console.warn(
          `[CircuitBreaker:${this.name}] √âchec - Fallback activ√©`
        );
        return fallback();
      }

      throw error;
    }
  }

  /**
   * Appel√© en cas de succ√®s
   */
  private onSuccess(): void {
    this.failureCount = 0;

    if (this.state === CircuitState.HALF_OPEN) {
      this.successCount++;

      if (this.successCount >= this.successThreshold) {
        this.state = CircuitState.CLOSED;
        this.successCount = 0;
        console.log(`[CircuitBreaker:${this.name}] Transition: HALF_OPEN ‚Üí CLOSED (recovered)`);
      }
    }
  }

  /**
   * Appel√© en cas d'√©chec
   */
  private onFailure(): void {
    this.failureCount++;
    this.totalFailures++;
    this.lastFailureTime = Date.now();

    if (this.state === CircuitState.HALF_OPEN) {
      // √âchec pendant test de r√©cup√©ration ‚Üí retour en OPEN
      this.state = CircuitState.OPEN;
      this.nextAttemptTime = Date.now() + this.timeout;
      console.error(
        `[CircuitBreaker:${this.name}] Transition: HALF_OPEN ‚Üí OPEN (recovery failed)`
      );
    } else if (this.failureCount >= this.failureThreshold) {
      // Trop d'√©checs en CLOSED ‚Üí passer en OPEN
      this.state = CircuitState.OPEN;
      this.nextAttemptTime = Date.now() + this.timeout;
      console.error(
        `[CircuitBreaker:${this.name}] Transition: CLOSED ‚Üí OPEN (threshold reached: ${this.failureCount}/${this.failureThreshold})`
      );
    }
  }

  /**
   * R√©cup√®re les statistiques du circuit breaker
   */
  getStats(): CircuitBreakerStats {
    return {
      state: this.state,
      failures: this.failureCount,
      successes: this.successCount,
      lastFailureTime: this.lastFailureTime,
      totalCalls: this.totalCalls,
      totalFailures: this.totalFailures,
    };
  }

  /**
   * R√©initialise le circuit breaker (utile pour les tests)
   */
  reset(): void {
    this.state = CircuitState.CLOSED;
    this.failureCount = 0;
    this.successCount = 0;
    this.lastFailureTime = undefined;
    this.nextAttemptTime = undefined;
  }

  /**
   * Force l'√©tat du circuit (utile pour les tests)
   */
  setState(state: CircuitState): void {
    this.state = state;
    if (state === CircuitState.OPEN) {
      this.nextAttemptTime = Date.now() + this.timeout;
    }
  }
}

/**
 * Factory pour cr√©er des circuit breakers nomm√©s
 */
export class CircuitBreakerFactory {
  private static instances = new Map<string, CircuitBreaker>();

  static get(
    name: string,
    options?: Partial<CircuitBreakerOptions>
  ): CircuitBreaker {
    if (!this.instances.has(name)) {
      this.instances.set(
        name,
        new CircuitBreaker({ ...options, name })
      );
    }
    return this.instances.get(name)!;
  }

  static reset(name: string): void {
    this.instances.get(name)?.reset();
  }

  static resetAll(): void {
    this.instances.forEach(cb => cb.reset());
  }

  static getStats(): Record<string, CircuitBreakerStats> {
    const stats: Record<string, CircuitBreakerStats> = {};
    this.instances.forEach((cb, name) => {
      stats[name] = cb.getStats();
    });
    return stats;
  }
}
